# SQL Injection Vulnerability Analysis Report

## Executive Summary
After analyzing the search functionality in the hangjegyzet codebase, I've identified **critical SQL injection vulnerabilities** in multiple areas. While the main search API uses parameterized queries through Supabase RPC calls (which are safe), there are several instances of unsafe string concatenation that could lead to SQL injection attacks.

## Critical Vulnerabilities Found

### 1. PostgreSQL Function with Direct String Concatenation (HIGH RISK)
**Location**: `/opt/hangjegyzet/supabase/migrations/20240111_search_indexes.sql`

```sql
-- Lines 91-94: Direct concatenation of user input into ILIKE queries
m.title ILIKE '%' || p_query || '%'
OR m.summary ILIKE '%' || p_query || '%'
OR (m.transcript->>'text') ILIKE '%' || p_query || '%'
OR m.action_items::text ILIKE '%' || p_query || '%'
```

**Vulnerability**: The `p_query` parameter is directly concatenated into the SQL query using `||` operator. An attacker could inject SQL by providing input like:
```
test%' OR 1=1 OR '%
```

### 2. Search Suggestions Function (MEDIUM RISK)
**Location**: `/opt/hangjegyzet/prisma/migrations/20240109_add_fts_search/migration.sql`

```sql
-- Line 272: Direct concatenation in ILIKE
AND sq.query ILIKE partial_query || '%'
```

**Vulnerability**: Similar to above, the `partial_query` parameter is directly concatenated without proper sanitization.

### 3. CRM Integration - Salesforce SOQL Injection (CRITICAL)
**Location**: `/opt/hangjegyzet/lib/integrations/crm/crm-service.ts`

```typescript
// Line 287: Direct string interpolation in SOQL query
const soql = query 
  ? `SELECT Id, Name, Email, Phone, Account.Name, Title FROM Contact WHERE Email LIKE '%${query}%' LIMIT 50`
  : `SELECT Id, Name, Email, Phone, Account.Name, Title FROM Contact LIMIT 50`
```

**Vulnerability**: Direct string interpolation of user input into a SOQL query. An attacker could inject SOQL commands by providing input like:
```
test%' OR Name != '' OR Email LIKE '%
```

### 4. MiniCRM Integration (MEDIUM RISK)
**Location**: `/opt/hangjegyzet/lib/integrations/minicrm.ts`

```typescript
// Lines 179-181: String interpolation in filter objects
{ Name: { $like: `%${query}%` } },
{ Email: { $like: `%${query}%` } },
{ Phone: { $like: `%${query}%` } },
```

**Vulnerability**: While this appears to be using a query builder syntax, the direct interpolation of user input could still be exploited depending on how the MiniCRM API processes these filters.

## Safe Implementations Found

The main search functionality at `/opt/hangjegyzet/lib/search/search-service.ts` correctly uses parameterized queries through Supabase RPC:

```typescript
// Safe implementation using RPC with parameters
const { data: results, error } = await this.supabase.rpc('search_meetings', {
  search_query: searchQuery.query,
  filter_user_id: searchQuery.filters?.userId || user.id,
  // ... other parameters
})
```

## Recommended Fixes

### 1. Fix PostgreSQL Functions
Replace direct concatenation with proper parameterized queries or use PostgreSQL's quote functions:

```sql
-- Instead of:
m.title ILIKE '%' || p_query || '%'

-- Use:
m.title ILIKE '%' || quote_literal(p_query) || '%'
-- OR better yet, use full-text search:
to_tsvector('hungarian', m.title) @@ plainto_tsquery('hungarian', p_query)
```

### 2. Fix CRM Integration
Use parameterized queries or proper escaping:

```typescript
// Safe approach using parameterized binding (if supported by the API)
const soql = query 
  ? `SELECT Id, Name, Email, Phone, Account.Name, Title FROM Contact WHERE Email LIKE :searchQuery LIMIT 50`
  : `SELECT Id, Name, Email, Phone, Account.Name, Title FROM Contact LIMIT 50`

// Then bind the parameter properly
const params = query ? { searchQuery: `%${query}%` } : {}

// OR use proper escaping function
const escapedQuery = query.replace(/['\\]/g, '\\$&')
```

### 3. Fix MiniCRM Integration
Validate and sanitize input before interpolation:

```typescript
// Sanitize the query input
const sanitizedQuery = query.replace(/[%_\\]/g, '\\$&')
const filters = {
  $or: [
    { Name: { $like: `%${sanitizedQuery}%` } },
    { Email: { $like: `%${sanitizedQuery}%` } },
    { Phone: { $like: `%${sanitizedQuery}%` } },
  ]
}
```

### 4. General Security Improvements

1. **Input Validation**: Add strict input validation at the API level:
```typescript
// Validate search query
if (!/^[\w\s\-\.@]+$/.test(query)) {
  throw new Error('Invalid search query')
}
```

2. **Use Full-Text Search**: Replace ILIKE queries with PostgreSQL's full-text search which is safer and more performant:
```sql
-- Use websearch_to_tsquery which handles special characters safely
m.search_vector @@ websearch_to_tsquery('hungarian', p_query)
```

3. **Implement Query Whitelisting**: For critical operations, maintain a whitelist of allowed search patterns.

4. **Add Security Tests**: Create unit tests that attempt SQL injection:
```typescript
describe('Search Security', () => {
  it('should handle SQL injection attempts safely', async () => {
    const maliciousQueries = [
      "'; DROP TABLE meetings; --",
      "' OR 1=1 --",
      "test%' OR 1=1 OR '%",
    ]
    
    for (const query of maliciousQueries) {
      const result = await searchService.search({ query })
      expect(result).not.toThrow()
      // Verify no unauthorized data is returned
    }
  })
})
```

## Priority Actions

1. **IMMEDIATE**: Fix the CRM integration SQL injection vulnerability
2. **HIGH**: Update PostgreSQL functions to use proper parameterization
3. **MEDIUM**: Implement input validation across all search endpoints
4. **ONGOING**: Add security testing and monitoring

## Conclusion

While the main search functionality uses safe parameterized queries through Supabase, several integration points and SQL functions contain critical SQL injection vulnerabilities. These should be addressed immediately to prevent potential data breaches or unauthorized access.